# 第二章

# 第三章（基于x86-64）

## 程序编译

### 预处理（#include #define #ifdef）->编译器编译（.s汇编代码）->汇编器（.o目标文件）->链接器（可执行文件）

#### 编译器编译包括：词法分析，语法分析，词义分析与中间代码产生，优化，目标代码生成

+ 词法分析：识别出句子中的一个个单词（if，while,begin等等）
+ 语法分析：分析句子的语法结构，将一个个单词识别为表达式，如识别` x + 0.618 * y`为算数表达式
+ 词义分析与中间代码产生：根据各个语法分析其含义（变量是否定义、类型是否正确等等），并进行初步翻译
+ 优化：对译文进行修饰，加工变换，去掉无用代码、循环优化
+ 目标代码生成：写出最后译文，生成汇编代码

#### <font color=red>链接(第7章读完总结)</font>:连接器将代码地址移到了不同的地址范围中

## 机器级代码是运行的内存地址为虚拟地址，提供的内存模型像一个非常大的字节数组

## PC(程序计数器)（x86-64 %rip）：将要执行的下一条指令的内存地址

## 整数寄存器存地址和整数数据，16个

## 条件码寄存器：最近执行的算术或逻辑指令的状态信息，CF:进位，ZF：0标志，SF：符号标志，最近操作结果为负数，OF：溢出标志，最近操作是否溢出，与算数指令配合使用

## 向量寄存器可以存储一个或多个整数以及浮点数

## 汇编

### pushq将内容压入栈

### %rax返回值，%rbx，%rbp被调用者保存（p调用q，其中这些寄存器的值<font color=red>不变</font>），%r10、%r11调用者保存(任意函数均可更改)

### mov类将数据从源位置复制到目标位置，（%rdi）：储存为地址，加括号指向该地址

### pushq入栈，popq先将寄存器中的数据保存到目的，再%rsp+8

### leaq （%rdi, %rsi, 4）, %rax      %rdi + 4 * %rsi, 传地址`leaq 8(%rsp), %rsi`

### 还有一堆算数等等，用到可以现查

### if else 要综合条件预测错误带来的影响以及两个分支先计算所占用的时间，选择条件控制转移还是条件数据转移（cmova...）

### cmpq、je都用于条件控制如while，do while

## 过程中运行的栈：应用于函数调用的内存管理：局部变量，保存寄存器的值

### 当所有的局部变量通过寄存器进行传递可以不用栈帧

### 需要取地址的值、局部变量为数组或结构时、超过6个参数的函数的参数函数、%rbp的值、返回值的地址将存入栈

### 栈向低地址增长

### 栈帧一般为定长开始前已分配好固定大小，但当有变长数组时，会用%rbp来确定新栈帧的起始，因为不知道大小，用%rbp来编辑

### callq会把callq后面紧接指令的地址保存在栈中，ret会把返回地址pop出并设置PC

### 递归通过被调用者寄存器保存值进入栈，每一次ret都会将寄存器值保存为上一次计算的结果，用于递归操作

### &E[2] leaq 8(%rdx), %rax            %rdx是数组名也就是起始地址

### 指向结构的指针就是结构第一个字节的地址，通过地址偏移进行访问

### 函数指针的值为该函数机器代码表示中第一条指令的地址

## 缓存区溢出：由于数组越界导致返回值地址以及保存的寄存器值发生改变，PC指向未知位置

+ 栈随机化：每次与运行前栈前面空出随机位置
+ 栈破坏检测：局部缓冲区与栈状态放入金丝雀，返回地址，返回寄存器存的值之前，检验是否改变
+ 限制哪部分内存存储可执行代码

### 可变长栈帧，%rbp帧指针，%rbp为被调用者寄存器，在栈帧中用%rbp + 偏移量访问元素。在函数结尾从栈中pop出%rbp之前的值，恢复%rbp 

```c++
pushq %rbp
movq %rsp %rbp


movq %rbp, %rsp
pop %rbp (栈的值给%rbp，恢复rbp，%rsp + 8，释放掉局部变量)
```



# 第四章（基于Y86-64，小端，低位在低地址）

## 指令：1字节：指令表示（低四位0x0 - 0xB,高四位0， 或opq、jxx、cmovxx），1字节源寄存、目标寄存，8字节偏移值/内存地址/立即数

## 读取指令时会对地址有最大地址限制，超过会ADR状态，非法指令，INS,AOK,正常，HLT，遇到halt指令

## <font color=red>push %rA</font>将元素放入%rA中的值读入%rsp - 8，之后更新%rsp；<font color=red>pop %rA</font>，先将内存中元素存入%rA，之后%rsp加8；<font color=red>ret与call</font>对于call指令还要将valp（下一条指令的地址）的值压入栈中，遇到ret将valm（从栈中得的值）给到PC，同时增加%rsp的值

## 一位信号Cnd，在更新PC前会检测，如果为1会跳转valC，不然就执行下一条指令

## 处理器执行过程

+ 读取：指令并解析是哪些指令，指令用的寄存器，指令偏移，设置下一条指令地址valp
+ 译码：读取相应的寄存器值
+ 执行：各种计算
+ 访存：将数据从内存读出，读的值为valM（ret用）或将数据写回内存
+ 写回：最多将两个结果写回内存valE写回计算的值，valM写回从数据内存中的值
+ 更新PC：使用valP或call的valc或栈中的valM

## 处理器采用流水线的形式同时执行不同指令，当出现分支，分支判断结果还没计算出来，使用分支预测的方式执行，预测错误回滚，所以ifelse会拖慢程序运行，减少ifelse使用

# 第七章链接

## 链接的工作

+ 符号（变量和函数）解析：将符号引用（使用函数）与符号的定义相连接

+ 重定位：将模块连在一起（merge），必须知道每个变量，函数的地址，将相对地址（虚拟地址）改变为绝对地址

executable：a.out，shared object file：.so

## Linker  Symbols

+ Global symbols, defined by module m
+ External symbols,are referenced by module m but defined by other modules
+ defined and referedced exclusively by module m:static function  static variable， not the local program variables 

## strong symbol：初始化的全局以及函数， weak symbol：未初始化的全局

### Multiple strong symbols are not allowed，error

### a strong symbol and multiple weak symbols choose the strong symbol

  
